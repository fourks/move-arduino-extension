#include <i2c_t3.h>
#ifdef I2C_DEBUG
#include <rbuf.h> // linker fix
#endif

const uint8_t ledPin = 13;
const uint8_t enablePin = 12;

// Function prototypes

void receiveEvent(size_t len);
void requestEvent(void);

uint8_t lastInstruction = 0;
uint8_t faderInput = 0;
    
void writeInitializationSequence() {
    byte initializationData [256] = {
        0x80, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xA0, 0x05, 0x01, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        // Data replaced by us
        // One record: address, instruction code sent to us, data report length, merge mode, offset in the final input report minus one
        0xA0, 0x02, 0x01, 0x01, 0x02, // T-button bitmask to OR (0x10)
        0xA0, 0x03, 0x01, 0x01, 0x03, // T-button bitmask to OR (0x80)
        0xA0, 0x04, 0x01, 0x01, 0x04, // T-button value (0x00-0xff)
        0xA0, 0x04, 0x01, 0x01, 0x05, // T-button value (0x00-0xff)
        0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 

        // Original initialization data from Sharp Shooter controller
//        0xA0, 0x02, 0x01, 0x01, 0x02, 
//        0xA0, 0x03, 0x01, 0x01, 0x04, 
//        0xA0, 0x04, 0x01, 0x01, 0x03, 
//        0xA0, 0x05, 0x01, 0x01, 0x05,
//        0xA0, 0x06, 0x01, 0x01, 0x01,
//        0xA0, 0x07, 0x01, 0x04, 0x2B,

        0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00,

        0x00,
    };
    Wire.write(initializationData, 256);
}


void setup()
{
    pinMode(ledPin, OUTPUT); // LED

    // This makes the extension device appear plugged out to the PS Move controller
    pinMode(enablePin, OUTPUT);
    digitalWrite(enablePin, HIGH);

    // Setup for Slave mode, address 0x44, pins 18/19, external pullups, 400kHz
    Wire.begin(I2C_SLAVE, 0x50, I2C_PINS_18_19, I2C_PULLUP_INT, I2C_RATE_400);

    // register events
    Wire.onReceive(receiveEvent);
    Wire.onRequest(requestEvent);

    // Simulate plugging ourselves into the PS Move controller on reboots
    delay(100);
    digitalWrite(enablePin, LOW);
}


void loop()
{
    digitalWrite(ledPin,HIGH); // double pulse LED while waiting for I2C requests
    delay(10);             // if the LED stops the slave is probably stuck in an ISR
    digitalWrite(ledPin,LOW);
    delay(100);
    digitalWrite(ledPin,HIGH);
    delay(10);
    digitalWrite(ledPin,LOW);
    delay(100);
    faderInput = analogRead(14) / 4;
}


// handle Rx Event (incoming I2C request/data)
void receiveEvent(size_t len)
{
    if(Wire.available())
    {
        lastInstruction = Wire.readByte();
    }
}


// handle Tx Event (outgoing I2C data)
void requestEvent(void)
{
    switch(lastInstruction)
    {
    case 0:
        writeInitializationSequence();
        break;
    case 2:
        Wire.write(0x10);
        break;
    case 3:
        Wire.write(0x80);
        break;
    case 4:
        Wire.write(faderInput);
        break;
    default:
        Wire.write(0x00);
        break;
    }
}

void print_i2c_status(void)
{
    switch(Wire.status())
    {
    case I2C_WAITING:  
        Serial.print("I2C waiting, no errors\n"); 
        break;
    case I2C_ADDR_NAK: 
        Serial.print("Slave addr not acknowledged\n"); 
        break;
    case I2C_DATA_NAK: 
        Serial.print("Slave data not acknowledged\n"); 
        break;
    case I2C_ARB_LOST: 
        Serial.print("Bus Error: Arbitration Lost\n"); 
        break;
    default:           
        Serial.print("I2C busy\n"); 
        break;
    }
}

